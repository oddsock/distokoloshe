# disTokoloshe

Self-hosted real-time voice, video, and screen-sharing web application. Built on LiveKit (WebRTC SFU), with end-to-end encryption, per-user volume controls, and high-framerate screen sharing (up to native resolution/refresh rate with AV1/VP9).

## Architecture

```
┌─────────┐       ┌──────────────┐       ┌─────────────┐
│ Browser  │──────▶│ nginx (web)  │──────▶│  API (Node) │
│ (SPA)    │       │  :80 / :443  │       │   :3000     │
└────┬─────┘       └──────────────┘       └──────┬──────┘
     │                                           │
     │  WebRTC (media)                           │ LiveKit token
     │                                           │ generation
     ▼                                           ▼
┌──────────────────────────────────────────────────────┐
│             LiveKit SFU (host network)               │
│  WS :7881  ·  UDP :50201-50400  ·  TURN :3478/5349  │
└──────────────────────────────────────────────────────┘
```

- **web** — nginx serving the Vite/React SPA. Reverse-proxies `/api/` to the API container and `/livekit/` to the LiveKit WebSocket.
- **api** — Node.js/Express. Handles user auth (JWT + SQLite), room management, SSE events for real-time presence, and LiveKit token generation.
- **desktop** — Tauri v2 desktop client (Windows/Linux/macOS). Shares UI code with the web app via `@distokoloshe/ui` package. Connects to any disTokoloshe server via configurable URL.
- **livekit** — LiveKit SFU running in host network mode for proper WebRTC ICE negotiation. Includes built-in TURN relay for restrictive NATs (production only).
- **certbot** — (production only) Auto-renews Let's Encrypt TLS certificates every 12 hours.

## Quick Start (Development)

```bash
# 1. Clone and generate secrets
git clone <repo-url> && cd distokoloshe
./infra/scripts/init.sh

# 2. Build and start
docker compose build
docker compose up -d

# 3. Open in browser
open http://localhost:3080
```

Register a user, create a room, and start talking. No TLS required for local development.

## Production Deployment

### Prerequisites

- A server with a public IP
- A domain name with DNS A record pointing to that IP
- Ports open on your firewall:

| Port | Protocol | Purpose |
|------|----------|---------|
| 80 | TCP | HTTP (ACME challenge + redirect to HTTPS) |
| 443 | TCP + UDP | HTTPS + HTTP/3 (QUIC) |
| 7881 | TCP | LiveKit WebSocket signaling |
| 3478 | UDP | TURN relay |
| 5349 | TCP | TURN/TLS relay |
| 50201-50400 | UDP | WebRTC media (RTP) |

### Step 1: Generate secrets

```bash
./infra/scripts/init.sh
```

### Step 2: Edit `.env`

Open `.env` and set your domain and email:

```
DOMAIN=chat.yourdomain.com
ACME_EMAIL=you@yourdomain.com
```

For production, set ports to standard values:

```
WEB_PORT=80
WEB_TLS_PORT=443
LK_PORT=7881
```

The rest (`LIVEKIT_API_KEY`, `LIVEKIT_API_SECRET`, `JWT_SECRET`) were auto-generated by `init.sh`. Don't change them after users have registered (JWT_SECRET invalidates all sessions, LIVEKIT keys break media relay).

### Step 3: Get TLS certificates

```bash
# Test first (doesn't hit rate limits)
./infra/scripts/init-certs.sh --dry-run

# If dry run succeeds, get a real certificate
./infra/scripts/init-certs.sh
```

This will:
1. Start nginx in HTTP-only mode on port 80
2. Run certbot to get a Let's Encrypt certificate via webroot challenge
3. Save the certificate to `./data/certs/`
4. Restart all services with TLS enabled (including the certbot renewal container)

### Step 4: Verify

Visit `https://chat.yourdomain.com`. You should see the login page with a valid TLS certificate.

LiveKit's entrypoint automatically detects TLS certs and switches to production mode:
- **Dev mode** (no certs): `use_external_ip: false`, TURN disabled
- **Prod mode** (certs present): `use_external_ip: true`, TURN enabled with TLS

### Certificate Renewal

Certbot runs as a persistent container (under the `production` profile) and checks for renewal every 12 hours. Certificates are stored on disk at `./data/certs/` (bind-mounted into containers), so they survive `docker volume prune`.

To manually force a renewal:

```bash
docker compose run --rm --entrypoint "certbot" certbot renew --force-renewal
docker compose restart web livekit
```

### Updating

```bash
git pull
docker compose build
docker compose up -d
```

The SQLite database in `data/api/` persists across rebuilds.

## Environment Variables

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `DOMAIN` | Yes (prod) | `localhost` | Domain for TLS certs and TURN server |
| `ACME_EMAIL` | Yes (prod) | — | Email for Let's Encrypt registration |
| `LIVEKIT_API_KEY` | Yes | — | LiveKit API key (generated by init.sh) |
| `LIVEKIT_API_SECRET` | Yes | — | LiveKit API secret (generated by init.sh) |
| `JWT_SECRET` | Yes | — | JWT signing secret (generated by init.sh) |
| `E2EE_SECRET` | Yes | — | E2EE key derivation secret (generated by init.sh) |
| `WEB_PORT` | No | `3080` | Host port for HTTP |
| `WEB_TLS_PORT` | No | `3443` | Host port for HTTPS / HTTP/3 |
| `LK_PORT` | No | `7881` | LiveKit WebSocket port |

## Features

- **Voice & video rooms** — Create voice or video rooms. Auto-joins your last room on login
- **Screen sharing** — Quality picker (720p/1080p/1080p60/native), browser-aware codec selection (AV1 on Firefox, VP9 on Chromium, VP8/H.264 on Safari), optional audio capture
- **End-to-end encryption** — AES-GCM via LiveKit Encoded Transforms with per-room HMAC-SHA256 key derivation. Graceful fallback to unencrypted on unsupported browsers (Safari)
- **Per-user volume control** — Individual volume sliders (0-200%) with persistent settings per participant
- **Democratic moderation** — Vote to jail disruptive users. 30-second voting window, quorum of 3, simple majority. Passed votes auto-create a timed jail room and kick the target from LiveKit. Room creator can lift punishments early
- **Whispers mode** — Room mode that shuffles participants into a random chain (Fisher-Yates). Chain updates live as users join/leave
- **Sound notifications** — 4 synthesized sound packs (Mystical Chimes, Mischievous Pops, Retro Arcade, Digital Whispers) with 8 events each. All generated via Web Audio API oscillators — no audio files
- **Real-time presence** — SSE-based online/offline status, room membership, vote/punishment/whispers events (13 event types)
- **Connection quality** — Live signal strength indicator with RTT (round-trip time) and jitter stats, server region display
- **Desktop client** — Tauri v2 app (Windows/Linux/macOS) sharing UI code with web via `@distokoloshe/ui`. Configurable server URL, window state persistence across restarts
- **Light/dark theme** — Toggle with persistent preference
- **Device selection** — Choose microphone, speaker, and camera from settings

## Project Structure

```
├── compose.yml              # Docker orchestration
├── .env                     # Secrets + config (generated by init.sh, gitignored)
├── package.json             # npm workspaces root
├── apps/
│   ├── web/                 # Vite + React SPA (nginx + Docker)
│   │   ├── nginx.conf       # Dev proxy config
│   │   ├── nginx.tls.conf   # Production TLS config (HTTPS + HTTP/3)
│   │   └── src/             # Web-specific entry (App.tsx, main.tsx)
│   ├── desktop/             # Tauri v2 desktop client
│   │   ├── src/             # Desktop entry (App.tsx, ServerConfig.tsx)
│   │   └── src-tauri/       # Rust shell (global shortcuts, window state)
│   └── server/              # Node.js/Express API (JWT + SQLite)
│       └── src/
│           ├── routes/      # auth, rooms, users, events (SSE)
│           ├── livekit.ts   # Token generation + E2EE key derivation
│           └── events.ts    # SSE client tracking + room membership
├── packages/
│   └── ui/                  # Shared React components, hooks, and utilities
│       └── src/
│           ├── pages/       # Login, Room
│           ├── hooks/       # useLiveKitRoom, useScreenShare, useAudioMixer, etc.
│           ├── components/  # ScreenShareView, VolumeSlider, UserList, etc.
│           └── lib/         # api.ts, sounds.ts, utils.ts, codec.ts
├── infra/
│   ├── livekit/             # LiveKit SFU config + entrypoint
│   └── scripts/             # init.sh, init-certs.sh
└── data/                    # Persistent data (gitignored)
    ├── api/                 # SQLite database
    ├── certs/               # TLS certificates (Let's Encrypt)
    └── certbot/www/         # ACME challenge webroot
```

## Planned Features

- **Music bot** — A LiveKit participant that streams internet radio (SomaFM) into a room with queue support and station switching. Blocked by a LiveKit server-side SDK bug where `wait_pc_connection` times out before the peer connection is established — reproduced in both `@livekit/rtc-node` and the Python `livekit` SDK (same underlying `livekit-ffi` Rust FFI). Archived at `archive/music-room` tag. Will revisit when LiveKit fixes the FFI peer connection handshake.
- **Desktop: global push-to-talk** — Register a system-wide hotkey via `tauri-plugin-global-shortcut` (plugin loaded, not yet wired to mute toggle).
- **Desktop: system tray menu** — Context menu with mute/deafen/quit actions.
- **Desktop: auto-updater** — `tauri-plugin-updater` with GitHub Releases endpoint for seamless updates.

## Security

- **Auth** — bcrypt password hashing (12 rounds), JWT with 7-day expiry (HS256), rate-limited login (20/15min) and registration (5/hour per IP)
- **E2EE** — AES-GCM end-to-end encryption via LiveKit Encoded Transforms. Per-room key derivation using HMAC-SHA256 with a dedicated `E2EE_SECRET` (separate from `JWT_SECRET`)
- **TLS** — TLS 1.2/1.3 only, HSTS with 2-year max-age, OCSP stapling, HTTP/3 (QUIC)
- **Headers** — CSP (frame-ancestors 'none', strict script/connect/media sources), X-Frame-Options DENY, X-Content-Type-Options nosniff, Referrer-Policy strict-origin-when-cross-origin, Permissions-Policy (camera/mic/display-capture self-only)
- **API** — CORS disabled at Express level (`origin: false`), nginx whitelists only Tauri desktop origins. 16KB body limit, parameterized SQL queries (no injection), input validation with regex/whitelist on all user inputs
- **Database** — SQLite with WAL mode, foreign key constraints enabled
- **SSE** — Per-user connection cap (3) and global cap (500), 30s keepalive ping
- **Desktop** — Tauri CSP restricts connect-src, media-src, script-src. WASM eval allowed only for livekit-client

## License

MIT
