# disTokoloshe

Self-hosted real-time voice, video, and screen-sharing web application. Built on LiveKit (WebRTC SFU), with end-to-end encryption, per-user volume controls, and high-framerate screen sharing (up to native resolution/refresh rate with AV1/VP9).

## Architecture

```
┌─────────┐       ┌──────────────┐       ┌─────────────┐
│ Browser  │──────▶│ nginx (web)  │──────▶│  API (Node) │
│ (SPA)    │       │  :80 / :443  │       │   :3000     │
└────┬─────┘       └──────────────┘       └──────┬──────┘
     │                                           │
     │  WebRTC (media)                           │ LiveKit token
     │                                           │ generation
     ▼                                           ▼
┌──────────────────────────────────────────────────────┐
│             LiveKit SFU (host network)               │
│  WS :7881  ·  UDP :50201-50400  ·  TURN :3478/5349  │
└──────────────────────────────────────────────────────┘
```

- **web** — nginx serving the Vite/React SPA. Reverse-proxies `/api/` to the API container and `/livekit/` to the LiveKit WebSocket.
- **api** — Node.js/Express. Handles user auth (JWT + SQLite), room management, SSE events for real-time presence, and LiveKit token generation.
- **livekit** — LiveKit SFU running in host network mode for proper WebRTC ICE negotiation. Includes built-in TURN relay for restrictive NATs (production only).
- **certbot** — (production only) Auto-renews Let's Encrypt TLS certificates every 12 hours.

## Quick Start (Development)

```bash
# 1. Clone and generate secrets
git clone <repo-url> && cd distokoloshe
./scripts/init.sh

# 2. Build and start
docker compose build
docker compose up -d

# 3. Open in browser
open http://localhost:3080
```

Register a user, create a room, and start talking. No TLS required for local development.

## Production Deployment

### Prerequisites

- A server with a public IP
- A domain name with DNS A record pointing to that IP
- Ports open on your firewall:

| Port | Protocol | Purpose |
|------|----------|---------|
| 80 | TCP | HTTP (ACME challenge + redirect to HTTPS) |
| 443 | TCP + UDP | HTTPS + HTTP/3 (QUIC) |
| 7881 | TCP | LiveKit WebSocket signaling |
| 3478 | UDP | TURN relay |
| 5349 | TCP | TURN/TLS relay |
| 50201-50400 | UDP | WebRTC media (RTP) |

### Step 1: Generate secrets

```bash
./scripts/init.sh
```

### Step 2: Edit `.env`

Open `.env` and set your domain and email:

```
DOMAIN=chat.yourdomain.com
ACME_EMAIL=you@yourdomain.com
```

For production, set ports to standard values:

```
WEB_PORT=80
WEB_TLS_PORT=443
LK_PORT=7881
```

The rest (`LIVEKIT_API_KEY`, `LIVEKIT_API_SECRET`, `JWT_SECRET`) were auto-generated by `init.sh`. Don't change them after users have registered (JWT_SECRET invalidates all sessions, LIVEKIT keys break media relay).

### Step 3: Get TLS certificates

```bash
# Test first (doesn't hit rate limits)
./scripts/init-certs.sh --dry-run

# If dry run succeeds, get a real certificate
./scripts/init-certs.sh
```

This will:
1. Start nginx in HTTP-only mode on port 80
2. Run certbot to get a Let's Encrypt certificate via webroot challenge
3. Save the certificate to `./data/certs/`
4. Restart all services with TLS enabled (including the certbot renewal container)

### Step 4: Verify

Visit `https://chat.yourdomain.com`. You should see the login page with a valid TLS certificate.

LiveKit's entrypoint automatically detects TLS certs and switches to production mode:
- **Dev mode** (no certs): `use_external_ip: false`, TURN disabled
- **Prod mode** (certs present): `use_external_ip: true`, TURN enabled with TLS

### Certificate Renewal

Certbot runs as a persistent container (under the `production` profile) and checks for renewal every 12 hours. Certificates are stored on disk at `./data/certs/` (bind-mounted into containers), so they survive `docker volume prune`.

To manually force a renewal:

```bash
docker compose run --rm --entrypoint "certbot" certbot renew --force-renewal
docker compose restart web livekit
```

### Updating

```bash
git pull
docker compose build
docker compose up -d
```

The SQLite database in `data/api/` persists across rebuilds.

## Environment Variables

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `DOMAIN` | Yes (prod) | `localhost` | Domain for TLS certs and TURN server |
| `ACME_EMAIL` | Yes (prod) | — | Email for Let's Encrypt registration |
| `LIVEKIT_API_KEY` | Yes | — | LiveKit API key (generated by init.sh) |
| `LIVEKIT_API_SECRET` | Yes | — | LiveKit API secret (generated by init.sh) |
| `JWT_SECRET` | Yes | — | JWT signing secret (generated by init.sh) |
| `E2EE_SECRET` | Yes | — | E2EE key derivation secret (generated by init.sh) |
| `WEB_PORT` | No | `3080` | Host port for HTTP |
| `WEB_TLS_PORT` | No | `3443` | Host port for HTTPS / HTTP/3 |
| `LK_PORT` | No | `7881` | LiveKit WebSocket port |

## Features

- **Voice & video rooms** — Auto-joins your last room on login
- **Screen sharing** — Quality picker (720p/1080p/1080p60/native), AV1 and VP9 codec support, optional audio capture
- **End-to-end encryption** — AES-GCM via LiveKit's E2EE (where browser supports `RTCRtpSender.prototype.transform`)
- **Per-user volume control** — Individual volume sliders (0-200%) with persistent settings
- **Real-time presence** — SSE-based online/offline status and room membership display
- **Light/dark theme** — Toggle with persistent preference
- **Device selection** — Choose microphone, speaker, and camera from settings

## Project Structure

```
├── compose.yml          # Docker orchestration
├── .env                 # Secrets + config (generated by init.sh, gitignored)
├── scripts/
│   ├── init.sh          # Generate .env with random secrets
│   └── init-certs.sh    # Bootstrap Let's Encrypt certs
├── data/                # Persistent data (gitignored)
│   ├── api/             # SQLite database
│   ├── certs/           # TLS certificates (Let's Encrypt)
│   └── certbot/www/     # ACME challenge webroot
├── api/                 # Node.js backend (Express + SQLite)
│   └── src/
│       ├── routes/      # auth, rooms, users, events (SSE)
│       ├── livekit.ts   # Token generation + E2EE key derivation
│       └── events.ts    # SSE client tracking + room membership
├── web/                 # Vite + React + TypeScript SPA
│   ├── nginx.conf       # Dev proxy config
│   ├── nginx.tls.conf   # Production TLS config (HTTPS + HTTP/3)
│   └── src/
│       ├── pages/       # Login, Room
│       ├── hooks/       # useLiveKitRoom, useScreenShare, useAudioMixer, etc.
│       └── components/  # ScreenShareView, VolumeSlider, UserList, etc.
└── livekit/
    ├── livekit.yaml     # LiveKit server config
    └── entrypoint.sh    # Auto-detects dev/prod mode
```

## Security

- **Auth** — bcrypt password hashing, JWT with 7-day expiry, rate-limited login (20/15min) and registration (5/hour)
- **E2EE** — AES-GCM end-to-end encryption via LiveKit Encoded Transforms (separate `E2EE_SECRET` from `JWT_SECRET`)
- **TLS** — TLS 1.2/1.3 only, HSTS with 2-year max-age, OCSP stapling, HTTP/3 (QUIC)
- **Headers** — CSP, X-Frame-Options DENY, Permissions-Policy (camera/mic/screenshare self-only)
- **API** — CORS locked down (`origin: false`), 16KB body limit, input validation, room ownership for deletion
- **SSE** — Per-user connection cap (3) and global cap (500)

## License

MIT
